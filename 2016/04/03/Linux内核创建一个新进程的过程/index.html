<!DOCTYPE html><html lang="null"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description"><title>Linux内核创建一个新进程的过程 | Siran Yang</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/normalize/3.0.3/normalize.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/0.6.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/0.6.0/grids-responsive-min.css"><link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.5.0/css/font-awesome.min.css"><script type="text/javascript" src="//cdn.bootcss.com/jquery/2.2.1/jquery.min.js"></script><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><link rel="alternate" type="application/atom+xml" href="/atom.xml"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">Linux内核创建一个新进程的过程</h1><a id="logo" href="/.">Siran Yang</a><p class="description">杨斯然的博客</p></div><div id="nav-menu"><a href="/." class="current"><i class="fa fa-home"> Start</i></a><a href="/archives/"><i class="fa fa-archive"> Archiv</i></a><a href="/about/"><i class="fa fa-user"> Über</i></a><a href="/atom.xml"><i class="fa fa-rss"> RSS</i></a></div></div><div id="layout" class="pure-g"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">Linux内核创建一个新进程的过程</h1><div class="post-meta">Apr 3, 2016<script src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js" async></script><span id="busuanzi_container_page_pv"> | <span id="busuanzi_value_page_pv"></span><span> Hits</span></span></div><div class="post-content"><p>杨斯然 原创作品转载请注明出处 <a href="http://mooc.study.163.com/course/USTC-1000029000" target="_blank" rel="external">《Linux内核分析》MOOC课程</a></p>
<h1 id="存储进程信息的task-struct"><a href="#存储进程信息的task-struct" class="headerlink" title="存储进程信息的task_struct"></a>存储进程信息的task_struct</h1><p><a href="http://codelab.shiyanlou.com/xref/linux-3.18.6/include/linux/sched.h#1235" target="_blank" rel="external">sched.h</a>中的<code>task_struct</code>结构体存储了各个进程相关的信息。这个结构体的定义也比较长，并且含有许多根据条件编译的成员。以下截取一些重要的内容，可以看到内核中所使用的数据结构是一些侵入式的十字链表：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> task_struct &#123;</span><br><span class="line">  <span class="keyword">volatile</span> <span class="keyword">long</span> state;	<span class="comment">/* 进程的执行状态 */</span></span><br><span class="line">  <span class="keyword">void</span> *<span class="built_in">stack</span>;	<span class="comment">/* 内核堆栈 */</span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">struct</span> list_head tasks;	<span class="comment">/* 所有进程 */</span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">struct</span> mm_struct *mm, *active_mm;	<span class="comment">/* 内存相关的信息 */</span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">pid_t</span> pid;	<span class="comment">/* 进程的pid */</span></span><br><span class="line">  <span class="keyword">pid_t</span> tgid;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">struct</span> task_struct __rcu *real_parent;	<span class="comment">/* 父进程 */</span></span><br><span class="line">  <span class="keyword">struct</span> task_struct __rcu *parent;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">struct</span> list_head children;	<span class="comment">/* 子进程 */</span></span><br><span class="line">  <span class="keyword">struct</span> list_head sibling;	<span class="comment">/* 兄弟进程链表 */</span></span><br><span class="line">  <span class="keyword">struct</span> task_struct *group_leader;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">struct</span> signal_struct *signal;	<span class="comment">/* 信号相关信息 */</span></span><br><span class="line">  <span class="keyword">struct</span> sighand_struct *sighand;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">struct</span> thread_struct thread;	<span class="comment">/* CPU相关的进程状态 */</span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">struct</span> fs_struct *fs;	<span class="comment">/* 文件系统相关信息 */</span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">struct</span> files_struct *files;	<span class="comment">/* 文件相关信息 */</span></span><br><span class="line">  <span class="comment">/* ... */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>thread_struct</code>存储每个进程的CPU相关的一些关键信息，如<em>sp</em>、<em>ip</em>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> thread_struct &#123;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span>		sp;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span>		ip;</span><br><span class="line">	<span class="comment">/* ... */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>内核堆栈实际上是一个大小为8K的union：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">union</span> thread_union &#123;</span><br><span class="line">	<span class="keyword">struct</span> thread_info thread_info;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="built_in">stack</span>[THREAD_SIZE/<span class="keyword">sizeof</span>(<span class="keyword">long</span>)];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> thread_info &#123;</span><br><span class="line">	<span class="keyword">struct</span> task_struct	*task;		<span class="comment">/* main task structure */</span></span><br><span class="line">	<span class="keyword">struct</span> exec_domain	*exec_domain;	<span class="comment">/* execution domain */</span></span><br><span class="line">	__u32			flags;		<span class="comment">/* low level flags */</span></span><br><span class="line">	__u32			status;		<span class="comment">/* thread synchronous flags */</span></span><br><span class="line">	__u32			cpu;		<span class="comment">/* current CPU */</span></span><br><span class="line">	<span class="keyword">int</span>			saved_preempt_count;</span><br><span class="line">	<span class="keyword">mm_segment_t</span>		addr_limit;</span><br><span class="line">	<span class="keyword">struct</span> restart_block    restart_block;</span><br><span class="line">	<span class="keyword">void</span> __user		*sysenter_return;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span>		sig_on_uaccess_error:<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span>		uaccess_err:<span class="number">1</span>;	<span class="comment">/* uaccess failed */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="创建新进程时对task-struct的处理"><a href="#创建新进程时对task-struct的处理" class="headerlink" title="创建新进程时对task_struct的处理"></a>创建新进程时对task_struct的处理</h1><p>无论是<code>sys_fork</code>、<code>sys_vfork</code>，还是<code>sys_clone</code>，实际上都是以不同的参数调用了<a href="http://codelab.shiyanlou.com/xref/linux-3.18.6/kernel/fork.c#1623" target="_blank" rel="external">fork.c</a>中的<code>do_fork</code>，例如<code>sys_clone</code>的函数体为：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> do_fork(clone_flags, newsp, <span class="number">0</span>, parent_tidptr, child_tidptr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里<code>do_fork</code>处理fork逻辑的主体，除了一些对参数的判断处理外，它执行了：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> task_struct *p =</span><br><span class="line">  copy_process(clone_flags, stack_start, stack_size, child_tidptr, <span class="literal">NULL</span>, trace);</span><br></pre></td></tr></table></figure>
<p>参考Linux Man Page中对<code>pid_t fork(void)</code>的描述：</p>
<blockquote>
<p>fork() creates a new process by duplicating the calling process. The new process, referred to as the child, is an exact duplicate of the calling process, referred to as the parent, except for the following points:</p>
<p>​    The child has its own unique process ID…<br>​    The child inherits copies of the parent’s set of open file descriptors…<br>​    …</p>
</blockquote>
<p>我们可以知道子进程是父进程的一个拷贝，但会对某些信息进行特化。这对应于<code>copy_process</code>中包括的一些动作：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> task_struct *p = dup_task_struct(current);</span><br><span class="line">copy_files(clone_flags, p);</span><br><span class="line">copy_fs(clone_flags, p);</span><br><span class="line">copy_sighand(clone_flags, p);</span><br><span class="line">copy_signal(clone_flags, p);</span><br><span class="line">copy_mm(clone_flags, p);</span><br><span class="line">copy_namespaces(clone_flags, p);</span><br><span class="line">copy_io(clone_flags, p);</span><br><span class="line">copy_thread(clone_flags, stack_start, stack_size, p);</span><br></pre></td></tr></table></figure>
<p>其中<code>dup_task_struct</code>进行了<code>task_struct</code>结构体的的复制：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> task_struct *tsk = alloc_task_struct_node(node);	<span class="comment">/* 分配新的task_struct结构体 */</span></span><br><span class="line"><span class="keyword">struct</span> thread_info *ti = alloc_thread_info_node(tsk, node);	<span class="comment">/* 分配新的内核栈 */</span></span><br><span class="line">arch_dup_task_struct(tsk, orig);	<span class="comment">/* *tsk = *orig，拷贝task_struct结构体 */</span></span><br><span class="line">tsk-&gt;<span class="built_in">stack</span> = ti;</span><br></pre></td></tr></table></figure>
<p><code>copy_files</code>到<code>copy_io</code>根据参数对一些进程相关的信息进行处理，<code>copy_thread</code>处理（拷贝）内核栈上CPU相关的信息，以便于子线程后续的恢复执行。其大概的流程包括：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> pt_regs *childregs = task_pt_regs(p);</span><br><span class="line">p-&gt;thread.sp = (<span class="keyword">unsigned</span> <span class="keyword">long</span>) childregs;	<span class="comment">/* 复制栈顶位置 */</span></span><br><span class="line">p-&gt;thread.sp0 = (<span class="keyword">unsigned</span> <span class="keyword">long</span>) (childregs+<span class="number">1</span>);</span><br><span class="line">*childregs = *current_pt_regs();	<span class="comment">/* 复制内核栈上保存的寄存器 */</span></span><br><span class="line">                                	<span class="comment">/* 这些步骤可以保证子进程可以恢复出和父进程一样的现场 */</span></span><br><span class="line">childregs-&gt;ax = <span class="number">0</span>;	<span class="comment">/* fork 在子进程中的返回值是0 */</span></span><br><span class="line"><span class="keyword">if</span> (sp)</span><br><span class="line">	childregs-&gt;sp = sp;</span><br><span class="line"><span class="comment">/* 子进程被调度后从system_call中的ret_from_fork开始执行 */</span></span><br><span class="line">p-&gt;thread.ip = (<span class="keyword">unsigned</span> <span class="keyword">long</span>) ret_from_fork;</span><br><span class="line"><span class="comment">/* ... */</span></span><br></pre></td></tr></table></figure>
<p><code>copy_thread</code>是架构相关的，它在<a href="http://codelab.shiyanlou.com/xref/linux-3.18.6/arch/x86/kernel/process_32.c#132" target="_blank" rel="external">process_32.c</a>中。</p>
<p><code>ret_from_fork</code>则在<a href="http://codelab.shiyanlou.com/xref/linux-3.18.6/arch/x86/kernel/entry_32.S#290" target="_blank" rel="external">entry_32.S</a>中，它跳转到<code>system_call</code>中的<code>system_exit</code>继续执行从系统调用中返回的逻辑：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">ENTRY(ret_from_fork)</span><br><span class="line">	CFI_STARTPROC</span><br><span class="line">	pushl_cfi %eax</span><br><span class="line">	call schedule_tail</span><br><span class="line">	GET_THREAD_INFO(%ebp)</span><br><span class="line">	popl_cfi %eax</span><br><span class="line">	pushl_cfi $0x0202		# Reset kernel eflags</span><br><span class="line">	popfl_cfi</span><br><span class="line">	jmp syscall_exit</span><br><span class="line">	CFI_ENDPROC</span><br><span class="line">END(ret_from_fork)</span><br></pre></td></tr></table></figure>
<h1 id="跟踪内核中fork的过程"><a href="#跟踪内核中fork的过程" class="headerlink" title="跟踪内核中fork的过程"></a>跟踪内核中fork的过程</h1><p>在<a href="https://github.com/mengning/menu/blob/master/test_fork.c" target="_blank" rel="external">menu</a>中加入Fork函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Fork</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> pid;</span><br><span class="line">	<span class="comment">/* fork another process */</span></span><br><span class="line">	pid = fork();</span><br><span class="line">	<span class="keyword">if</span> (pid&lt;<span class="number">0</span>) </span><br><span class="line">	&#123; </span><br><span class="line">		<span class="comment">/* error occurred */</span></span><br><span class="line">		<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>,<span class="string">"Fork Failed!"</span>);</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">	&#125; </span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (pid==<span class="number">0</span>) </span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">/*	 child process 	*/</span></span><br><span class="line">    	<span class="built_in">printf</span>(<span class="string">"This is Child Process!\n"</span>);</span><br><span class="line">	&#125; </span><br><span class="line">	<span class="keyword">else</span> </span><br><span class="line">	&#123; 	</span><br><span class="line">		<span class="comment">/* 	parent process	 */</span></span><br><span class="line">    	<span class="built_in">printf</span>(<span class="string">"This is Parent Process!\n"</span>);</span><br><span class="line">		<span class="comment">/* parent will wait for the child to complete*/</span></span><br><span class="line">		wait(<span class="literal">NULL</span>);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"Child Complete!\n"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们在gdb中设置一些断点，并让内核停在<code>sys_clone</code>/<code>do_fork</code>处：</p>
<img src="/2016/04/03/Linux内核创建一个新进程的过程/do_fork.png" alt="do_fork" title="do_fork">
<p>可以看到<code>do_fork</code>进入了<code>copy_process</code>。而<code>copy_process</code>先是进入<code>dup_task_struct</code>对<code>task_struct</code>进行拷贝：</p>
<img src="/2016/04/03/Linux内核创建一个新进程的过程/dup_task_struct.png" alt="dup_task_struct" title="dup_task_struct">
<p>之后是拷贝和特化内核栈信息的<code>copy_thread</code>：</p>
<img src="/2016/04/03/Linux内核创建一个新进程的过程/copy_thread.png" alt="copy_thread" title="copy_thread">
<p>我们在<code>ret_from_fork</code>处设置断点，可以观察到子进程在这里开始执行：</p>
<img src="/2016/04/03/Linux内核创建一个新进程的过程/ret_from_fork.png" alt="ret_from_fork" title="ret_from_fork">
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>内核创建子进程的过程可以简单的总结为对父进程进行拷贝，然后进行一系列关于子进程的特化，如内核栈信息，返回位置等。<code>task_struct</code>结构体被用于存储内核中和每个进程相关的信息。</p>
</div><script type="text/javascript" src="/js/share.js?v=0.0.0" async></script><a data-url="http://blog.sirany.me/2016/04/03/Linux内核创建一个新进程的过程/" data-id="cin4aqo2h0003c1v99xl0taq0" class="article-share-link">Aktie</a><div class="tags"><a href="/tags/Linux/">Linux</a></div><div class="post-nav"><a href="/2016/04/10/Linux中装载和启动可执行程序/" class="pre">Linux中装载和启动可执行程序</a><a href="/2016/03/27/system-call中断的处理过程/" class="next">system_call中断的处理过程</a></div></div></div></div><div class="pure-u-1-4"><div id="sidebar"><div class="widget"><form action="//www.google.com/search" method="get" accept-charset="utf-8" target="_blank" class="search-form"><input type="text" name="q" maxlength="20" placeholder="Search"/><input type="hidden" name="sitesearch" value="http://blog.sirany.me"/></form></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> Kategorien</i></div></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> Tags</i></div><div class="tagcloud"><a href="/tags/Linux/" style="font-size: 15px;">Linux</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> Letzte</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2016/04/15/Linux中的进程调度与进程切换/">Linux中的进程调度与进程切换</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/04/10/Linux中装载和启动可执行程序/">Linux中装载和启动可执行程序</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/04/03/Linux内核创建一个新进程的过程/">Linux内核创建一个新进程的过程</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/03/27/system-call中断的处理过程/">system_call中断的处理过程</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/03/20/系统调用的两种使用方式/">系统调用的两种使用方式</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/03/13/跟踪Linux内核的启动过程/">跟踪Linux内核的启动过程</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/03/06/一个简单的时间片轮转多道程序内核代码分析/">一个简单的时间片轮转多道程序内核代码分析</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/02/28/一个简单C程序的反汇编/">一个简单C程序的反汇编</a></li></ul></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">© <a href="/." rel="nofollow">Siran Yang.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a id="rocket" href="#top" class="show"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.pack.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="/css/jquery.fancybox.css?v=0.0.0"><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>