<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>Linux内核创建一个新进程的过程 | Siran Yang | 杨斯然</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="杨斯然 原创作品转载请注明出处 《Linux内核分析》MOOC课程
存储进程信息的task_structsched.h中的task_struct结构体存储了各个进程相关的信息。这个结构体的定义也比较长，并且含有许多根据条件编译的成员。以下截取一些重要的内容，可以看到内核中所使用的数据结构是一些侵入式的十字链表：
1234567891011121314151617181920212223242526">
<meta property="og:type" content="article">
<meta property="og:title" content="Linux内核创建一个新进程的过程">
<meta property="og:url" content="http://yangsiran.github.com/2016/04/03/Linux内核创建一个新进程的过程/index.html">
<meta property="og:site_name" content="Siran Yang | 杨斯然">
<meta property="og:description" content="杨斯然 原创作品转载请注明出处 《Linux内核分析》MOOC课程
存储进程信息的task_structsched.h中的task_struct结构体存储了各个进程相关的信息。这个结构体的定义也比较长，并且含有许多根据条件编译的成员。以下截取一些重要的内容，可以看到内核中所使用的数据结构是一些侵入式的十字链表：
1234567891011121314151617181920212223242526">
<meta property="og:image" content="http://yangsiran.github.com/2016/04/03/Linux内核创建一个新进程的过程/do_fork.png">
<meta property="og:image" content="http://yangsiran.github.com/2016/04/03/Linux内核创建一个新进程的过程/dup_task_struct.png">
<meta property="og:image" content="http://yangsiran.github.com/2016/04/03/Linux内核创建一个新进程的过程/copy_thread.png">
<meta property="og:image" content="http://yangsiran.github.com/2016/04/03/Linux内核创建一个新进程的过程/ret_from_fork.png">
<meta property="og:updated_time" content="2016-04-04T07:57:45.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Linux内核创建一个新进程的过程">
<meta name="twitter:description" content="杨斯然 原创作品转载请注明出处 《Linux内核分析》MOOC课程
存储进程信息的task_structsched.h中的task_struct结构体存储了各个进程相关的信息。这个结构体的定义也比较长，并且含有许多根据条件编译的成员。以下截取一些重要的内容，可以看到内核中所使用的数据结构是一些侵入式的十字链表：
1234567891011121314151617181920212223242526">
<meta name="twitter:image" content="http://yangsiran.github.com/2016/04/03/Linux内核创建一个新进程的过程/do_fork.png">
  
    <link rel="alternate" href="/atom.xml" title="Siran Yang | 杨斯然" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Siran Yang | 杨斯然</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Buscar"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" results="0" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yangsiran.github.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-Linux内核创建一个新进程的过程" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/04/03/Linux内核创建一个新进程的过程/" class="article-date">
  <time datetime="2016-04-03T13:20:10.000Z" itemprop="datePublished">2016-04-03</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      Linux内核创建一个新进程的过程
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>杨斯然 原创作品转载请注明出处 <a href="http://mooc.study.163.com/course/USTC-1000029000" target="_blank" rel="external">《Linux内核分析》MOOC课程</a></p>
<h1 id="存储进程信息的task-struct"><a href="#存储进程信息的task-struct" class="headerlink" title="存储进程信息的task_struct"></a>存储进程信息的task_struct</h1><p><a href="http://codelab.shiyanlou.com/xref/linux-3.18.6/include/linux/sched.h#1235" target="_blank" rel="external">sched.h</a>中的<code>task_struct</code>结构体存储了各个进程相关的信息。这个结构体的定义也比较长，并且含有许多根据条件编译的成员。以下截取一些重要的内容，可以看到内核中所使用的数据结构是一些侵入式的十字链表：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> task_struct &#123;</span><br><span class="line">  <span class="keyword">volatile</span> <span class="keyword">long</span> state;	<span class="comment">/* 进程的执行状态 */</span></span><br><span class="line">  <span class="keyword">void</span> *<span class="built_in">stack</span>;	<span class="comment">/* 内核堆栈 */</span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">struct</span> list_head tasks;	<span class="comment">/* 所有进程 */</span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">struct</span> mm_struct *mm, *active_mm;	<span class="comment">/* 内存相关的信息 */</span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">pid_t</span> pid;	<span class="comment">/* 进程的pid */</span></span><br><span class="line">  <span class="keyword">pid_t</span> tgid;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">struct</span> task_struct __rcu *real_parent;	<span class="comment">/* 父进程 */</span></span><br><span class="line">  <span class="keyword">struct</span> task_struct __rcu *parent;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">struct</span> list_head children;	<span class="comment">/* 子进程 */</span></span><br><span class="line">  <span class="keyword">struct</span> list_head sibling;	<span class="comment">/* 兄弟进程链表 */</span></span><br><span class="line">  <span class="keyword">struct</span> task_struct *group_leader;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">struct</span> signal_struct *signal;	<span class="comment">/* 信号相关信息 */</span></span><br><span class="line">  <span class="keyword">struct</span> sighand_struct *sighand;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">struct</span> thread_struct thread;	<span class="comment">/* CPU相关的进程状态 */</span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">struct</span> fs_struct *fs;	<span class="comment">/* 文件系统相关信息 */</span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">struct</span> files_struct *files;	<span class="comment">/* 文件相关信息 */</span></span><br><span class="line">  <span class="comment">/* ... */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>thread_struct</code>存储每个进程的CPU相关的一些关键信息，如<em>sp</em>、<em>ip</em>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> thread_struct &#123;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span>		sp;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span>		ip;</span><br><span class="line">	<span class="comment">/* ... */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>内核堆栈实际上是一个大小为8K的union：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">union</span> thread_union &#123;</span><br><span class="line">	<span class="keyword">struct</span> thread_info thread_info;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="built_in">stack</span>[THREAD_SIZE/<span class="keyword">sizeof</span>(<span class="keyword">long</span>)];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> thread_info &#123;</span><br><span class="line">	<span class="keyword">struct</span> task_struct	*task;		<span class="comment">/* main task structure */</span></span><br><span class="line">	<span class="keyword">struct</span> exec_domain	*exec_domain;	<span class="comment">/* execution domain */</span></span><br><span class="line">	__u32			flags;		<span class="comment">/* low level flags */</span></span><br><span class="line">	__u32			status;		<span class="comment">/* thread synchronous flags */</span></span><br><span class="line">	__u32			cpu;		<span class="comment">/* current CPU */</span></span><br><span class="line">	<span class="keyword">int</span>			saved_preempt_count;</span><br><span class="line">	<span class="keyword">mm_segment_t</span>		addr_limit;</span><br><span class="line">	<span class="keyword">struct</span> restart_block    restart_block;</span><br><span class="line">	<span class="keyword">void</span> __user		*sysenter_return;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span>		sig_on_uaccess_error:<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span>		uaccess_err:<span class="number">1</span>;	<span class="comment">/* uaccess failed */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="创建新进程时对task-struct的处理"><a href="#创建新进程时对task-struct的处理" class="headerlink" title="创建新进程时对task_struct的处理"></a>创建新进程时对task_struct的处理</h1><p>无论是<code>sys_fork</code>、<code>sys_vfork</code>，还是<code>sys_clone</code>，实际上都是以不同的参数调用了<a href="http://codelab.shiyanlou.com/xref/linux-3.18.6/kernel/fork.c#1623" target="_blank" rel="external">fork.c</a>中的<code>do_fork</code>，例如<code>sys_clone</code>的函数体为：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> do_fork(clone_flags, newsp, <span class="number">0</span>, parent_tidptr, child_tidptr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里<code>do_fork</code>处理fork逻辑的主体，除了一些对参数的判断处理外，它执行了：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> task_struct *p =</span><br><span class="line">  copy_process(clone_flags, stack_start, stack_size, child_tidptr, <span class="literal">NULL</span>, trace);</span><br></pre></td></tr></table></figure>
<p>参考Linux Man Page中对<code>pid_t fork(void)</code>的描述：</p>
<blockquote>
<p>fork() creates a new process by duplicating the calling process. The new process, referred to as the child, is an exact duplicate of the calling process, referred to as the parent, except for the following points:</p>
<p>​    The child has its own unique process ID…<br>​    The child inherits copies of the parent’s set of open file descriptors…<br>​    …</p>
</blockquote>
<p>我们可以知道子进程是父进程的一个拷贝，但会对某些信息进行特化。这对应于<code>copy_process</code>中包括的一些动作：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> task_struct *p = dup_task_struct(current);</span><br><span class="line">copy_files(clone_flags, p);</span><br><span class="line">copy_fs(clone_flags, p);</span><br><span class="line">copy_sighand(clone_flags, p);</span><br><span class="line">copy_signal(clone_flags, p);</span><br><span class="line">copy_mm(clone_flags, p);</span><br><span class="line">copy_namespaces(clone_flags, p);</span><br><span class="line">copy_io(clone_flags, p);</span><br><span class="line">copy_thread(clone_flags, stack_start, stack_size, p);</span><br></pre></td></tr></table></figure>
<p>其中<code>dup_task_struct</code>进行了<code>task_struct</code>结构体的的复制：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> task_struct *tsk = alloc_task_struct_node(node);	<span class="comment">/* 分配新的task_struct结构体 */</span></span><br><span class="line"><span class="keyword">struct</span> thread_info *ti = alloc_thread_info_node(tsk, node);	<span class="comment">/* 分配新的内核栈 */</span></span><br><span class="line">arch_dup_task_struct(tsk, orig);	<span class="comment">/* *tsk = *orig，拷贝task_struct结构体 */</span></span><br><span class="line">tsk-&gt;<span class="built_in">stack</span> = ti;</span><br></pre></td></tr></table></figure>
<p><code>copy_files</code>到<code>copy_io</code>根据参数对一些进程相关的信息进行处理，<code>copy_thread</code>处理（拷贝）内核栈上CPU相关的信息，以便于子线程后续的恢复执行。其大概的流程包括：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> pt_regs *childregs = task_pt_regs(p);</span><br><span class="line">p-&gt;thread.sp = (<span class="keyword">unsigned</span> <span class="keyword">long</span>) childregs;	<span class="comment">/* 复制栈顶位置 */</span></span><br><span class="line">p-&gt;thread.sp0 = (<span class="keyword">unsigned</span> <span class="keyword">long</span>) (childregs+<span class="number">1</span>);</span><br><span class="line">*childregs = *current_pt_regs();	<span class="comment">/* 复制内核栈上保存的寄存器 */</span></span><br><span class="line">                                	<span class="comment">/* 这些步骤可以保证子进程可以恢复出和父进程一样的现场 */</span></span><br><span class="line">childregs-&gt;ax = <span class="number">0</span>;	<span class="comment">/* fork 在子进程中的返回值是0 */</span></span><br><span class="line"><span class="keyword">if</span> (sp)</span><br><span class="line">	childregs-&gt;sp = sp;</span><br><span class="line"><span class="comment">/* 子进程被调度后从system_call中的ret_from_fork开始执行 */</span></span><br><span class="line">p-&gt;thread.ip = (<span class="keyword">unsigned</span> <span class="keyword">long</span>) ret_from_fork;</span><br><span class="line"><span class="comment">/* ... */</span></span><br></pre></td></tr></table></figure>
<p><code>copy_thread</code>是架构相关的，它在<a href="http://codelab.shiyanlou.com/xref/linux-3.18.6/arch/x86/kernel/process_32.c#132" target="_blank" rel="external">process_32.c</a>中。</p>
<p><code>ret_from_fork</code>则在<a href="http://codelab.shiyanlou.com/xref/linux-3.18.6/arch/x86/kernel/entry_32.S#290" target="_blank" rel="external">entry_32.S</a>中，它跳转到<code>system_call</code>中的<code>system_exit</code>继续执行从系统调用中返回的逻辑：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">ENTRY(ret_from_fork)</span><br><span class="line">	CFI_STARTPROC</span><br><span class="line">	pushl_cfi %eax</span><br><span class="line">	call schedule_tail</span><br><span class="line">	GET_THREAD_INFO(%ebp)</span><br><span class="line">	popl_cfi %eax</span><br><span class="line">	pushl_cfi $0x0202		# Reset kernel eflags</span><br><span class="line">	popfl_cfi</span><br><span class="line">	jmp syscall_exit</span><br><span class="line">	CFI_ENDPROC</span><br><span class="line">END(ret_from_fork)</span><br></pre></td></tr></table></figure>
<h1 id="跟踪内核中fork的过程"><a href="#跟踪内核中fork的过程" class="headerlink" title="跟踪内核中fork的过程"></a>跟踪内核中fork的过程</h1><p>在<a href="https://github.com/mengning/menu/blob/master/test_fork.c" target="_blank" rel="external">menu</a>中加入Fork函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Fork</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> pid;</span><br><span class="line">	<span class="comment">/* fork another process */</span></span><br><span class="line">	pid = fork();</span><br><span class="line">	<span class="keyword">if</span> (pid&lt;<span class="number">0</span>) </span><br><span class="line">	&#123; </span><br><span class="line">		<span class="comment">/* error occurred */</span></span><br><span class="line">		<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>,<span class="string">"Fork Failed!"</span>);</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">	&#125; </span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (pid==<span class="number">0</span>) </span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">/*	 child process 	*/</span></span><br><span class="line">    	<span class="built_in">printf</span>(<span class="string">"This is Child Process!\n"</span>);</span><br><span class="line">	&#125; </span><br><span class="line">	<span class="keyword">else</span> </span><br><span class="line">	&#123; 	</span><br><span class="line">		<span class="comment">/* 	parent process	 */</span></span><br><span class="line">    	<span class="built_in">printf</span>(<span class="string">"This is Parent Process!\n"</span>);</span><br><span class="line">		<span class="comment">/* parent will wait for the child to complete*/</span></span><br><span class="line">		wait(<span class="literal">NULL</span>);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"Child Complete!\n"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们在gdb中设置一些断点，并让内核停在<code>sys_clone</code>/<code>do_fork</code>处：</p>
<img src="/2016/04/03/Linux内核创建一个新进程的过程/do_fork.png" alt="do_fork" title="do_fork">
<p>可以看到<code>do_fork</code>进入了<code>copy_process</code>。而<code>copy_process</code>先是进入<code>dup_task_struct</code>对<code>task_struct</code>进行拷贝：</p>
<img src="/2016/04/03/Linux内核创建一个新进程的过程/dup_task_struct.png" alt="dup_task_struct" title="dup_task_struct">
<p>之后是拷贝和特化内核栈信息的<code>copy_thread</code>：</p>
<img src="/2016/04/03/Linux内核创建一个新进程的过程/copy_thread.png" alt="copy_thread" title="copy_thread">
<p>我们在<code>ret_from_fork</code>处设置断点，可以观察到子进程在这里开始执行：</p>
<img src="/2016/04/03/Linux内核创建一个新进程的过程/ret_from_fork.png" alt="ret_from_fork" title="ret_from_fork">
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>内核创建子进程的过程可以简单的总结为对父进程进行拷贝，然后进行一系列关于子进程的特化，如内核栈信息，返回位置等。<code>task_struct</code>结构体被用于存储内核中和每个进程相关的信息。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yangsiran.github.com/2016/04/03/Linux内核创建一个新进程的过程/" data-id="cimvcgfny0001ohv964xsq27m" class="article-share-link">Compartir</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Linux/">Linux</a></li></ul>

    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2016/04/10/Linux中装载和启动可执行程序/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Nuevo</strong>
      <div class="article-nav-title">
        
          Linux中装载和启动可执行程序
        
      </div>
    </a>
  
  
    <a href="/2016/03/27/system-call中断的处理过程/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Viejo</strong>
      <div class="article-nav-title">system_call中断的处理过程</div>
    </a>
  
</nav>

  
</article>

</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/Linux/">Linux</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Nube de Tags</h3>
    <div class="widget tagcloud">
      <a href="/tags/Linux/" style="font-size: 10px;">Linux</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archivos</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/04/">April 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/03/">March 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/02/">February 2016</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Posts recientes</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2016/04/10/Linux中装载和启动可执行程序/">Linux中装载和启动可执行程序</a>
          </li>
        
          <li>
            <a href="/2016/04/03/Linux内核创建一个新进程的过程/">Linux内核创建一个新进程的过程</a>
          </li>
        
          <li>
            <a href="/2016/03/27/system-call中断的处理过程/">system_call中断的处理过程</a>
          </li>
        
          <li>
            <a href="/2016/03/20/系统调用的两种使用方式/">系统调用的两种使用方式</a>
          </li>
        
          <li>
            <a href="/2016/03/13/跟踪Linux内核的启动过程/">跟踪Linux内核的启动过程</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2016 Siran Yang<br>
      Construido por <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>




  </div>
</body>
</html>