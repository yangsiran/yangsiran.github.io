<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>Siran Yang | 杨斯然</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description">
<meta property="og:type" content="website">
<meta property="og:title" content="Siran Yang | 杨斯然">
<meta property="og:url" content="http://yangsiran.github.com/index.html">
<meta property="og:site_name" content="Siran Yang | 杨斯然">
<meta property="og:description">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Siran Yang | 杨斯然">
<meta name="twitter:description">
  
    <link rel="alternate" href="/atom.xml" title="Siran Yang | 杨斯然" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Siran Yang | 杨斯然</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Buscar"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" results="0" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yangsiran.github.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-Linux中装载和启动可执行程序" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/04/10/Linux中装载和启动可执行程序/" class="article-date">
  <time datetime="2016-04-10T09:42:14.000Z" itemprop="datePublished">2016-04-10</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/04/10/Linux中装载和启动可执行程序/">Linux中装载和启动可执行程序</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>杨斯然 原创作品转载请注明出处  <a href="http://mooc.study.163.com/course/USTC-1000029000" target="_blank" rel="external">《Linux内核分析》MOOC课程</a></p>
<h1 id="ELF可执行格式"><a href="#ELF可执行格式" class="headerlink" title="ELF可执行格式"></a>ELF可执行格式</h1><p>Linux中可执行文件以<a href="https://en.wikipedia.org/wiki/Executable_and_Linkable_Format" target="_blank" rel="external">ELF格式</a>组织。包括可执行程序（executable），目标文件（object）和共享库（shared library）。ELF文件中包括ELF header、Program header table（将文件组织为若干segment）、Section header table（将文件组织为若干section），以及若干部分的数据。内核负责读取ELF文件，并将数据加载到进程内存空间对应的位置。</p>
<p><img src="https://upload.wikimedia.org/wikipedia/commons/7/77/Elf-layout--en.svg" alt="ELF"></p>
<h1 id="Linux中的装载与链接"><a href="#Linux中的装载与链接" class="headerlink" title="Linux中的装载与链接"></a>Linux中的装载与链接</h1><p><a href="https://gist.github.com/yangsiran/731d976a3aa8842d667aa0b6dbdd8833" target="_blank" rel="external">https://gist.github.com/yangsiran/731d976a3aa8842d667aa0b6dbdd8833</a></p>
<p>Linux中使用exec*系列的系统调用来加载程序，被加载的程序覆盖原有进程的空间，并从程序入口出开始执行。</p>
<p>代码可以以库的形式组织，其中动态链接库可以被多个可执行程序共享。Linux中使用<code>ldd</code>可以查看程序所链接的动态库。动态库也可以使用<code>dlopen</code>来在运行时加载，使用<code>dlsym</code>可以从动态库中找到相应的符号。</p>
<h1 id="内核对execve系统调用的处理"><a href="#内核对execve系统调用的处理" class="headerlink" title="内核对execve系统调用的处理"></a>内核对execve系统调用的处理</h1><p>在<a href="http://codelab.shiyanlou.com/xref/linux-3.18.6/fs/exec.c#1604" target="_blank" rel="external">exec.c</a>中我们可以看到定义系统调用<code>execve</code>的代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">SYSCALL_DEFINE3(execve,</span><br><span class="line">		<span class="keyword">const</span> <span class="keyword">char</span> __user *, filename,</span><br><span class="line">		<span class="keyword">const</span> <span class="keyword">char</span> __user *<span class="keyword">const</span> __user *, argv,</span><br><span class="line">		<span class="keyword">const</span> <span class="keyword">char</span> __user *<span class="keyword">const</span> __user *, envp)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> do_execve(getname(filename), argv, envp);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">do_execve</span><span class="params">(<span class="keyword">struct</span> filename *filename,</span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">char</span> __user *<span class="keyword">const</span> __user *__argv,</span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">char</span> __user *<span class="keyword">const</span> __user *__envp)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">struct</span> user_arg_ptr argv = &#123; .ptr.native = __argv &#125;;</span><br><span class="line">	<span class="keyword">struct</span> user_arg_ptr envp = &#123; .ptr.native = __envp &#125;;</span><br><span class="line">	<span class="keyword">return</span> do_execve_common(filename, argv, envp);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">do_execve_common</span><span class="params">(<span class="keyword">struct</span> filename *filename,</span><br><span class="line">				<span class="keyword">struct</span> user_arg_ptr argv,</span><br><span class="line">				<span class="keyword">struct</span> user_arg_ptr envp)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="comment">/* ... */</span></span><br><span class="line">	<span class="keyword">struct</span> linux_binprm *bprm;</span><br><span class="line">	<span class="keyword">struct</span> file *file = do_open_exec(filename);</span><br><span class="line">	copy_strings(bprm-&gt;envc, envp, bprm);</span><br><span class="line">	copy_strings(bprm-&gt;argc, argv, bprm);</span><br><span class="line">	exec_binprm(bprm);	<span class="comment">/* search_binary_handler(bprm); */</span></span><br><span class="line">	<span class="comment">/* ... */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>search_binary_handler</code>查找合适的handler来加载二进制可执行文件。<a href="http://codelab.shiyanlou.com/xref/linux-3.18.6/fs/exec.c#1352" target="_blank" rel="external">exec.c</a>中可以看到一段遍历格式的代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">search_binary_handler</span><span class="params">(<span class="keyword">struct</span> linux_binprm *bprm)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">struct</span> linux_binfmt *fmt;</span><br><span class="line"></span><br><span class="line">	list_for_each_entry(fmt, &amp;formats, lh) &#123;</span><br><span class="line">		<span class="keyword">if</span> (!try_module_get(fmt-&gt;module))</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		fmt-&gt;load_binary(bprm);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">/* ... */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里<code>&amp;formats</code>是包含所有可执行文件格式的链表，在<a href="http://codelab.shiyanlou.com/xref/linux-3.18.6/fs/binfmt_elf.c#82" target="_blank" rel="external">binfmt_elf.c</a>中我们可以看到关于ELF格式的节点：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">struct</span> linux_binfmt elf_format = &#123;</span><br><span class="line">	.module		= THIS_MODULE,</span><br><span class="line">	.load_binary	= load_elf_binary,</span><br><span class="line">	.load_shlib	= load_elf_library,</span><br><span class="line">	.core_dump	= elf_core_dump,</span><br><span class="line">	.min_coredump	= ELF_EXEC_PAGESIZE,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> __<span class="function">init <span class="title">init_elf_binfmt</span><span class="params">(<span class="keyword">void</span>)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	register_binfmt(&amp;elf_format);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中<code>load_elf_binary</code>为处理ELF格式加载逻辑的函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">load_elf_binary</span><span class="params">(<span class="keyword">struct</span> linux_binprm *bprm)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">char</span> * elf_interpreter；</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* ... */</span></span><br><span class="line">	<span class="keyword">if</span> (elf_interpreter)</span><br><span class="line">		elf_entry = load_elf_interp(&amp;loc-&gt;interp_elf_ex,</span><br><span class="line">					    interpreter,</span><br><span class="line">					    &amp;interp_map_addr,</span><br><span class="line">					    load_bias);</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		elf_entry = loc-&gt;elf_ex.e_entry;</span><br><span class="line"></span><br><span class="line">	start_thread(regs, elf_entry, bprm-&gt;p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>除了各种格式的处理之外，如果可执行文件用到了外部的动态共享库，内核则会将返回位置设置为loader的入口，将控制权转交给loader，由loader进行共享库的查找、加载，调转到程序入口；否则内核将返回位置设置为程序入口<code>loc-&gt;elf_ex.e_entry</code>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span></span><br><span class="line"><span class="title">start_thread</span><span class="params">(<span class="keyword">struct</span> pt_regs *regs, <span class="keyword">unsigned</span> <span class="keyword">long</span> new_ip, <span class="keyword">unsigned</span> <span class="keyword">long</span> new_sp)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	set_user_gs(regs, <span class="number">0</span>);</span><br><span class="line">	regs-&gt;fs		= <span class="number">0</span>;</span><br><span class="line">	regs-&gt;ds		= __USER_DS;</span><br><span class="line">	regs-&gt;es		= __USER_DS;</span><br><span class="line">	regs-&gt;ss		= __USER_DS;</span><br><span class="line">	regs-&gt;cs		= __USER_CS;</span><br><span class="line">	regs-&gt;ip		= new_ip;</span><br><span class="line">	regs-&gt;sp		= new_sp;</span><br><span class="line">	regs-&gt;flags		= X86_EFLAGS_IF;</span><br><span class="line">	set_thread_flag(TIF_NOTIFY_RESUME);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>start_thread</code>设置内核栈顶的寄存器，使得进程从中断中返回后可到达合适的位置。</p>
<h1 id="使用gdb跟踪execve系统调用"><a href="#使用gdb跟踪execve系统调用" class="headerlink" title="使用gdb跟踪execve系统调用"></a>使用gdb跟踪execve系统调用</h1><p>我们在<a href="https://github.com/mengning/menu/blob/master/test_exec.c" target="_blank" rel="external">menu</a>中加入<code>fork</code>一个子进程并加载<code>hello</code>的命令<em>exec</em>。</p>
<p>我们使用gdb在上述提到的几个处理函数的入口设置断点：</p>
<img src="/2016/04/10/Linux中装载和启动可执行程序/set_breaks.png" alt="设置断点" title="设置断点">
<p>可以看到内核在处理可执行文件加载时的确停在了这些位置上：</p>
<img src="/2016/04/10/Linux中装载和启动可执行程序/breaks.png" alt="断点" title="断点">
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>当我们在Linux下执行一个新程序的时候，一般来说需要进行装载和链接两个动作。其中装载由内核中断处理函数完成，如需要进行动态库的链接，内核则会将控制权交给loader让其完成工作。程序员也可以在程序运行的过程中自行调用loader进行动态库的加载和符号的解析。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yangsiran.github.com/2016/04/10/Linux中装载和启动可执行程序/" data-id="cimvc5rtd0000x0v9ggv0yqhn" class="article-share-link">Compartir</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Linux/">Linux</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-Linux内核创建一个新进程的过程" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/04/03/Linux内核创建一个新进程的过程/" class="article-date">
  <time datetime="2016-04-03T13:20:10.000Z" itemprop="datePublished">2016-04-03</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/04/03/Linux内核创建一个新进程的过程/">Linux内核创建一个新进程的过程</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>杨斯然 原创作品转载请注明出处 <a href="http://mooc.study.163.com/course/USTC-1000029000" target="_blank" rel="external">《Linux内核分析》MOOC课程</a></p>
<h1 id="存储进程信息的task-struct"><a href="#存储进程信息的task-struct" class="headerlink" title="存储进程信息的task_struct"></a>存储进程信息的task_struct</h1><p><a href="http://codelab.shiyanlou.com/xref/linux-3.18.6/include/linux/sched.h#1235" target="_blank" rel="external">sched.h</a>中的<code>task_struct</code>结构体存储了各个进程相关的信息。这个结构体的定义也比较长，并且含有许多根据条件编译的成员。以下截取一些重要的内容，可以看到内核中所使用的数据结构是一些侵入式的十字链表：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> task_struct &#123;</span><br><span class="line">  <span class="keyword">volatile</span> <span class="keyword">long</span> state;	<span class="comment">/* 进程的执行状态 */</span></span><br><span class="line">  <span class="keyword">void</span> *<span class="built_in">stack</span>;	<span class="comment">/* 内核堆栈 */</span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">struct</span> list_head tasks;	<span class="comment">/* 所有进程 */</span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">struct</span> mm_struct *mm, *active_mm;	<span class="comment">/* 内存相关的信息 */</span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">pid_t</span> pid;	<span class="comment">/* 进程的pid */</span></span><br><span class="line">  <span class="keyword">pid_t</span> tgid;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">struct</span> task_struct __rcu *real_parent;	<span class="comment">/* 父进程 */</span></span><br><span class="line">  <span class="keyword">struct</span> task_struct __rcu *parent;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">struct</span> list_head children;	<span class="comment">/* 子进程 */</span></span><br><span class="line">  <span class="keyword">struct</span> list_head sibling;	<span class="comment">/* 兄弟进程链表 */</span></span><br><span class="line">  <span class="keyword">struct</span> task_struct *group_leader;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">struct</span> signal_struct *signal;	<span class="comment">/* 信号相关信息 */</span></span><br><span class="line">  <span class="keyword">struct</span> sighand_struct *sighand;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">struct</span> thread_struct thread;	<span class="comment">/* CPU相关的进程状态 */</span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">struct</span> fs_struct *fs;	<span class="comment">/* 文件系统相关信息 */</span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">struct</span> files_struct *files;	<span class="comment">/* 文件相关信息 */</span></span><br><span class="line">  <span class="comment">/* ... */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>thread_struct</code>存储每个进程的CPU相关的一些关键信息，如<em>sp</em>、<em>ip</em>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> thread_struct &#123;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span>		sp;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span>		ip;</span><br><span class="line">	<span class="comment">/* ... */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>内核堆栈实际上是一个大小为8K的union：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">union</span> thread_union &#123;</span><br><span class="line">	<span class="keyword">struct</span> thread_info thread_info;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="built_in">stack</span>[THREAD_SIZE/<span class="keyword">sizeof</span>(<span class="keyword">long</span>)];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> thread_info &#123;</span><br><span class="line">	<span class="keyword">struct</span> task_struct	*task;		<span class="comment">/* main task structure */</span></span><br><span class="line">	<span class="keyword">struct</span> exec_domain	*exec_domain;	<span class="comment">/* execution domain */</span></span><br><span class="line">	__u32			flags;		<span class="comment">/* low level flags */</span></span><br><span class="line">	__u32			status;		<span class="comment">/* thread synchronous flags */</span></span><br><span class="line">	__u32			cpu;		<span class="comment">/* current CPU */</span></span><br><span class="line">	<span class="keyword">int</span>			saved_preempt_count;</span><br><span class="line">	<span class="keyword">mm_segment_t</span>		addr_limit;</span><br><span class="line">	<span class="keyword">struct</span> restart_block    restart_block;</span><br><span class="line">	<span class="keyword">void</span> __user		*sysenter_return;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span>		sig_on_uaccess_error:<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span>		uaccess_err:<span class="number">1</span>;	<span class="comment">/* uaccess failed */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="创建新进程时对task-struct的处理"><a href="#创建新进程时对task-struct的处理" class="headerlink" title="创建新进程时对task_struct的处理"></a>创建新进程时对task_struct的处理</h1><p>无论是<code>sys_fork</code>、<code>sys_vfork</code>，还是<code>sys_clone</code>，实际上都是以不同的参数调用了<a href="http://codelab.shiyanlou.com/xref/linux-3.18.6/kernel/fork.c#1623" target="_blank" rel="external">fork.c</a>中的<code>do_fork</code>，例如<code>sys_clone</code>的函数体为：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> do_fork(clone_flags, newsp, <span class="number">0</span>, parent_tidptr, child_tidptr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里<code>do_fork</code>处理fork逻辑的主体，除了一些对参数的判断处理外，它执行了：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> task_struct *p =</span><br><span class="line">  copy_process(clone_flags, stack_start, stack_size, child_tidptr, <span class="literal">NULL</span>, trace);</span><br></pre></td></tr></table></figure>
<p>参考Linux Man Page中对<code>pid_t fork(void)</code>的描述：</p>
<blockquote>
<p>fork() creates a new process by duplicating the calling process. The new process, referred to as the child, is an exact duplicate of the calling process, referred to as the parent, except for the following points:</p>
<p>​    The child has its own unique process ID…<br>​    The child inherits copies of the parent’s set of open file descriptors…<br>​    …</p>
</blockquote>
<p>我们可以知道子进程是父进程的一个拷贝，但会对某些信息进行特化。这对应于<code>copy_process</code>中包括的一些动作：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> task_struct *p = dup_task_struct(current);</span><br><span class="line">copy_files(clone_flags, p);</span><br><span class="line">copy_fs(clone_flags, p);</span><br><span class="line">copy_sighand(clone_flags, p);</span><br><span class="line">copy_signal(clone_flags, p);</span><br><span class="line">copy_mm(clone_flags, p);</span><br><span class="line">copy_namespaces(clone_flags, p);</span><br><span class="line">copy_io(clone_flags, p);</span><br><span class="line">copy_thread(clone_flags, stack_start, stack_size, p);</span><br></pre></td></tr></table></figure>
<p>其中<code>dup_task_struct</code>进行了<code>task_struct</code>结构体的的复制：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> task_struct *tsk = alloc_task_struct_node(node);	<span class="comment">/* 分配新的task_struct结构体 */</span></span><br><span class="line"><span class="keyword">struct</span> thread_info *ti = alloc_thread_info_node(tsk, node);	<span class="comment">/* 分配新的内核栈 */</span></span><br><span class="line">arch_dup_task_struct(tsk, orig);	<span class="comment">/* *tsk = *orig，拷贝task_struct结构体 */</span></span><br><span class="line">tsk-&gt;<span class="built_in">stack</span> = ti;</span><br></pre></td></tr></table></figure>
<p><code>copy_files</code>到<code>copy_io</code>根据参数对一些进程相关的信息进行处理，<code>copy_thread</code>处理（拷贝）内核栈上CPU相关的信息，以便于子线程后续的恢复执行。其大概的流程包括：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> pt_regs *childregs = task_pt_regs(p);</span><br><span class="line">p-&gt;thread.sp = (<span class="keyword">unsigned</span> <span class="keyword">long</span>) childregs;	<span class="comment">/* 复制栈顶位置 */</span></span><br><span class="line">p-&gt;thread.sp0 = (<span class="keyword">unsigned</span> <span class="keyword">long</span>) (childregs+<span class="number">1</span>);</span><br><span class="line">*childregs = *current_pt_regs();	<span class="comment">/* 复制内核栈上保存的寄存器 */</span></span><br><span class="line">                                	<span class="comment">/* 这些步骤可以保证子进程可以恢复出和父进程一样的现场 */</span></span><br><span class="line">childregs-&gt;ax = <span class="number">0</span>;	<span class="comment">/* fork 在子进程中的返回值是0 */</span></span><br><span class="line"><span class="keyword">if</span> (sp)</span><br><span class="line">	childregs-&gt;sp = sp;</span><br><span class="line"><span class="comment">/* 子进程被调度后从system_call中的ret_from_fork开始执行 */</span></span><br><span class="line">p-&gt;thread.ip = (<span class="keyword">unsigned</span> <span class="keyword">long</span>) ret_from_fork;</span><br><span class="line"><span class="comment">/* ... */</span></span><br></pre></td></tr></table></figure>
<p><code>copy_thread</code>是架构相关的，它在<a href="http://codelab.shiyanlou.com/xref/linux-3.18.6/arch/x86/kernel/process_32.c#132" target="_blank" rel="external">process_32.c</a>中。</p>
<p><code>ret_from_fork</code>则在<a href="http://codelab.shiyanlou.com/xref/linux-3.18.6/arch/x86/kernel/entry_32.S#290" target="_blank" rel="external">entry_32.S</a>中，它跳转到<code>system_call</code>中的<code>system_exit</code>继续执行从系统调用中返回的逻辑：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">ENTRY(ret_from_fork)</span><br><span class="line">	CFI_STARTPROC</span><br><span class="line">	pushl_cfi %eax</span><br><span class="line">	call schedule_tail</span><br><span class="line">	GET_THREAD_INFO(%ebp)</span><br><span class="line">	popl_cfi %eax</span><br><span class="line">	pushl_cfi $0x0202		# Reset kernel eflags</span><br><span class="line">	popfl_cfi</span><br><span class="line">	jmp syscall_exit</span><br><span class="line">	CFI_ENDPROC</span><br><span class="line">END(ret_from_fork)</span><br></pre></td></tr></table></figure>
<h1 id="跟踪内核中fork的过程"><a href="#跟踪内核中fork的过程" class="headerlink" title="跟踪内核中fork的过程"></a>跟踪内核中fork的过程</h1><p>在<a href="https://github.com/mengning/menu/blob/master/test_fork.c" target="_blank" rel="external">menu</a>中加入Fork函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Fork</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> pid;</span><br><span class="line">	<span class="comment">/* fork another process */</span></span><br><span class="line">	pid = fork();</span><br><span class="line">	<span class="keyword">if</span> (pid&lt;<span class="number">0</span>) </span><br><span class="line">	&#123; </span><br><span class="line">		<span class="comment">/* error occurred */</span></span><br><span class="line">		<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>,<span class="string">"Fork Failed!"</span>);</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">	&#125; </span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (pid==<span class="number">0</span>) </span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">/*	 child process 	*/</span></span><br><span class="line">    	<span class="built_in">printf</span>(<span class="string">"This is Child Process!\n"</span>);</span><br><span class="line">	&#125; </span><br><span class="line">	<span class="keyword">else</span> </span><br><span class="line">	&#123; 	</span><br><span class="line">		<span class="comment">/* 	parent process	 */</span></span><br><span class="line">    	<span class="built_in">printf</span>(<span class="string">"This is Parent Process!\n"</span>);</span><br><span class="line">		<span class="comment">/* parent will wait for the child to complete*/</span></span><br><span class="line">		wait(<span class="literal">NULL</span>);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"Child Complete!\n"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们在gdb中设置一些断点，并让内核停在<code>sys_clone</code>/<code>do_fork</code>处：</p>
<img src="/2016/04/03/Linux内核创建一个新进程的过程/do_fork.png" alt="do_fork" title="do_fork">
<p>可以看到<code>do_fork</code>进入了<code>copy_process</code>。而<code>copy_process</code>先是进入<code>dup_task_struct</code>对<code>task_struct</code>进行拷贝：</p>
<img src="/2016/04/03/Linux内核创建一个新进程的过程/dup_task_struct.png" alt="dup_task_struct" title="dup_task_struct">
<p>之后是拷贝和特化内核栈信息的<code>copy_thread</code>：</p>
<img src="/2016/04/03/Linux内核创建一个新进程的过程/copy_thread.png" alt="copy_thread" title="copy_thread">
<p>我们在<code>ret_from_fork</code>处设置断点，可以观察到子进程在这里开始执行：</p>
<img src="/2016/04/03/Linux内核创建一个新进程的过程/ret_from_fork.png" alt="ret_from_fork" title="ret_from_fork">
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>内核创建子进程的过程可以简单的总结为对父进程进行拷贝，然后进行一系列关于子进程的特化，如内核栈信息，返回位置等。<code>task_struct</code>结构体被用于存储内核中和每个进程相关的信息。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yangsiran.github.com/2016/04/03/Linux内核创建一个新进程的过程/" data-id="cimvc5rtj0002x0v9lmwwdz3q" class="article-share-link">Compartir</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Linux/">Linux</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-system-call中断的处理过程" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/03/27/system-call中断的处理过程/" class="article-date">
  <time datetime="2016-03-27T12:19:30.000Z" itemprop="datePublished">2016-03-27</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/03/27/system-call中断的处理过程/">system_call中断的处理过程</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>杨斯然 原创作品转载请注明出处 <a href="http://mooc.study.163.com/course/USTC-1000029000" target="_blank" rel="external">《Linux内核分析》MOOC课程</a></p>
<h1 id="使用gdb跟踪系统调用内核函数"><a href="#使用gdb跟踪系统调用内核函数" class="headerlink" title="使用gdb跟踪系统调用内核函数"></a>使用gdb跟踪系统调用内核函数</h1><p>我们在<a href="https://github.com/mengning/menu" target="_blank" rel="external">menu</a>的test.c中加入一些调用了系统调用的命令：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Hello</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> write(<span class="number">1</span>, <span class="string">"hello, world\n"</span>, <span class="number">14</span>) &gt;= <span class="number">0</span> ? <span class="number">0</span> : <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">HelloAsm</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *greeting = <span class="string">"hello, world\n"</span>;</span><br><span class="line">    <span class="keyword">int</span> ret;</span><br><span class="line">    <span class="keyword">asm</span> (   <span class="string">"mov $1, %%ebx\n\t"</span></span><br><span class="line">            <span class="string">"mov $14, %%edx\n\t"</span></span><br><span class="line">            <span class="string">"mov $4, %%eax\n\t"</span></span><br><span class="line">            <span class="string">"int $0x80\n\t"</span></span><br><span class="line">            <span class="string">"mov %%eax, %0"</span></span><br><span class="line">            : <span class="string">"=m"</span>(ret)</span><br><span class="line">            : <span class="string">"c"</span>(greeting));</span><br><span class="line">    <span class="keyword">return</span> ret &gt;= <span class="number">0</span> ? <span class="number">0</span> : <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">PrintPid</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%u\n"</span>, getpid());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Time</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">time_t</span> tt;</span><br><span class="line">    <span class="keyword">struct</span> tm *t;</span><br><span class="line">    tt = time(<span class="literal">NULL</span>);</span><br><span class="line">    t = localtime(&amp;tt);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"time:%d:%d:%d:%d:%d:%d\n"</span>,t-&gt;tm_year+<span class="number">1900</span>, t-&gt;tm_mon, t-&gt;tm_mday, t-&gt;tm_hour, t-&gt;tm_min, t-&gt;tm_sec);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    PrintMenuOS();</span><br><span class="line">    SetPrompt(<span class="string">"MenuOS&gt;&gt;"</span>);</span><br><span class="line">    MenuConfig(<span class="string">"time"</span>, <span class="string">"Get the current time."</span>, Time);</span><br><span class="line">    MenuConfig(<span class="string">"print-pid"</span>, <span class="string">"Print Pid."</span>, PrintPid);</span><br><span class="line">    MenuConfig(<span class="string">"hello"</span>, <span class="string">"Say Hello."</span>, Hello);</span><br><span class="line">    MenuConfig(<span class="string">"hello-asm"</span>, <span class="string">"Say Hello (ASM)."</span>, HelloAsm);</span><br><span class="line">    MenuConfig(<span class="string">"version"</span>,<span class="string">"XXX V1.0(Menu program v1.0 inside)"</span>,<span class="literal">NULL</span>);</span><br><span class="line">    MenuConfig(<span class="string">"quit"</span>,<span class="string">"Quit from XXX"</span>,Quit);</span><br><span class="line"></span><br><span class="line">    ExecuteMenu();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>编译menu到rootfs中并启动内核，可以看到这些新加入的命令出现在命令列表中：</p>
 <img src="/2016/03/27/system-call中断的处理过程/syscall.png" alt="syscall" title="syscall">
<p>我们可以在time调用对应的内核处理函数sys_time处设置断点：</p>
<img src="/2016/03/27/system-call中断的处理过程/break.png" alt="break" title="break">
<p>可以看到sys_time在内核源码中并不是一个标准的C函数，而是由宏所定义的：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">SYSCALL_DEFINE1(time, <span class="keyword">time_t</span> __user *, tloc)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">time_t</span> i = get_seconds();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (tloc) &#123;</span><br><span class="line">		<span class="keyword">if</span> (put_user(i,tloc))</span><br><span class="line">			<span class="keyword">return</span> -EFAULT;</span><br><span class="line">	&#125;</span><br><span class="line">	force_successful_syscall_return();</span><br><span class="line">	<span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在处理完系统调用后返回前，内核会进入调度逻辑：</p>
<img src="/2016/03/27/system-call中断的处理过程/schedule.png" alt="schedule" title="schedule">
<p>在这之后的汇编代码无法被gdb跟踪。</p>
<p>值得注意的是一些内核符号可以被gdb引用，但gdb无法使内核在这些符号处停下来，如sys_getpid、system_call：</p>
<img src="/2016/03/27/system-call中断的处理过程/unstoppable.png" alt="unstoppable" title="unstoppable">
<h1 id="entry-32-S中system-call对应代码"><a href="#entry-32-S中system-call对应代码" class="headerlink" title="entry_32.S中system_call对应代码"></a>entry_32.S中system_call对应代码</h1><p><a href="http://codelab.shiyanlou.com/xref/linux-3.18.6/arch/x86/kernel/entry_32.S" target="_blank" rel="external">arch/x86/kernel/entry_32.S</a>中从<code>ENTRY(system_call)</code>开始的一段代码负责处理system_call中断，当<code>int 0x80</code>执行时系统便会跳转到此处。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">ENTRY(system_call)</span><br><span class="line">	RING0_INT_FRAME			# can't unwind into user space anyway</span><br><span class="line">	ASM_CLAC</span><br><span class="line">	pushl_cfi %eax			# save orig_eax</span><br><span class="line">	SAVE_ALL</span><br><span class="line">	GET_THREAD_INFO(%ebp)</span><br><span class="line">					# system call tracing in operation / emulation</span><br><span class="line">	testl $_TIF_WORK_SYSCALL_ENTRY,TI_flags(%ebp)</span><br><span class="line">	jnz syscall_trace_entry</span><br><span class="line">	cmpl $(NR_syscalls), %eax</span><br><span class="line">	jae syscall_badsys</span><br><span class="line">syscall_call:</span><br><span class="line">	call *sys_call_table(,%eax,4)</span><br><span class="line">syscall_after_call:</span><br><span class="line">	movl %eax,PT_EAX(%esp)		# store the return value</span><br><span class="line">syscall_exit:</span><br><span class="line">	LOCKDEP_SYS_EXIT</span><br><span class="line">	DISABLE_INTERRUPTS(CLBR_ANY)	# make sure we don't miss an interrupt</span><br><span class="line">					# setting need_resched or sigpending</span><br><span class="line">					# between sampling and the iret</span><br><span class="line">	TRACE_IRQS_OFF</span><br><span class="line">	movl TI_flags(%ebp), %ecx</span><br><span class="line">	testl $_TIF_ALLWORK_MASK, %ecx	# current-&gt;work</span><br><span class="line">	jne syscall_exit_work</span><br><span class="line"></span><br><span class="line">restore_all:</span><br><span class="line">	TRACE_IRQS_IRET</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>要完整理解这段代码需要充分的内核知识，但是从总体上仍然可以看出内核处理系统调用中断的过程。</p>
<img src="/2016/03/27/system-call中断的处理过程/system_call_workflow.png" alt="system_call_workflow" title="system_call_workflow">
<ol>
<li>保存所有的寄存器：<code>SAVE_ALL</code></li>
<li>根据<code>%eax</code>中的系统调用号调用相应的处理函数：<code>call *sys_call_table(,%eax,4)</code></li>
<li>结束处理之前的工作：<code>jne syscall_exit_work</code></li>
<li>恢复寄存器：<code>RESTORE_REGS 4</code></li>
<li>从中断中返回：<code>INTERRUPT_RETURN</code></li>
</ol>
<p><code>system_exit_work</code>:</p>
<ol>
<li><code>work_notifysig</code>（处理信号）</li>
<li><code>schedule</code></li>
<li>跳转回上述的4（<em>restore_all</em>）</li>
</ol>
<p><code>schedule</code>在<a href="http://codelab.shiyanlou.com/xref/linux-3.18.6/kernel/sched/core.c" target="_blank" rel="external">kernel/sched/core.c</a>中，调用<code>__schedule</code>进行调度：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">asmlinkage __visible <span class="keyword">void</span> __<span class="function">sched <span class="title">schedule</span><span class="params">(<span class="keyword">void</span>)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">struct</span> task_struct *tsk = current;</span><br><span class="line"></span><br><span class="line">	sched_submit_work(tsk);</span><br><span class="line">	__schedule();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yangsiran.github.com/2016/03/27/system-call中断的处理过程/" data-id="cimvc5rto0004x0v9pzpoqns8" class="article-share-link">Compartir</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Linux/">Linux</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-系统调用的两种使用方式" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/03/20/系统调用的两种使用方式/" class="article-date">
  <time datetime="2016-03-20T06:12:26.000Z" itemprop="datePublished">2016-03-20</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/03/20/系统调用的两种使用方式/">系统调用的两种使用方式</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>杨斯然 原创作品转载请注明出处 《Linux内核分析》MOOC课程<a href="http://mooc.study.163.com/course/USTC-1000029000" target="_blank" rel="external">http://mooc.study.163.com/course/USTC-1000029000</a></p>
<p>本文以两段调用Linux系统调用的代码为例分析Linux系统调用的工作方式。</p>
<h1 id="系统调用的介绍"><a href="#系统调用的介绍" class="headerlink" title="系统调用的介绍"></a>系统调用的介绍</h1><p>系统调用的实际实现方式为由特殊指令 <code>int 0x80</code> 发起一个软中断。CPU捕获到中断后，保存程序的上下文到栈上，包括：</p>
<ol>
<li>堆栈顶地址；</li>
<li>状态字；</li>
<li><code>cs:eip</code> 的值。</li>
</ol>
<p>然后根据中断的类型从中断向量表中选择对应的中断服务例程（ISR）的地址载入<code>cs:eip</code>，CPU进入内核态开始执行ISR。在系统调用的情况下（0x80中断），ISR会根据传入的的系统调用号调用具体的实现函数来响应系统调用。当ISR完成工作后，会从栈上恢复这些上下文。</p>
<p>在x86架构中，系统调用的参数传递使用寄存器来完成：</p>
<table>
<thead>
<tr>
<th style="text-align:center">Syscall #</th>
<th style="text-align:center">Param 1</th>
<th style="text-align:center">Param 2</th>
<th style="text-align:center">Param 3</th>
<th style="text-align:center">Param 4</th>
<th style="text-align:center">Param 5</th>
<th style="text-align:center">Param 6</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">eax</td>
<td style="text-align:center">ebx</td>
<td style="text-align:center">ecx</td>
<td style="text-align:center">edx</td>
<td style="text-align:center">esi</td>
<td style="text-align:center">edi</td>
<td style="text-align:center">ebp</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th style="text-align:center">Return value</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">eax</td>
</tr>
</tbody>
</table>
<p>当然，实际的使用中操作系统通常将系统调用封装成C函数，程序员只需要引入适当的头文件并调用对应的函数即可完成相应的系统调用。而这些封装后的C API的实现上也使用了<code>int $0x80</code>指令来完成具体的工作。</p>
<h1 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h1><p>以下我们分别使用这两种方式来完成对<code>write</code>的系统调用：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *greeting = <span class="string">"hello, world\n"</span>;</span><br><span class="line">    <span class="keyword">return</span> write(<span class="number">1</span>, greeting, <span class="number">14</span>) &gt;= <span class="number">0</span> ? <span class="number">0</span> : <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对<code>int $0x80</code>的直接调用使用内嵌汇编来完成：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *greeting = <span class="string">"hello, world\n"</span>;</span><br><span class="line">    <span class="keyword">int</span> ret;</span><br><span class="line">    <span class="keyword">asm</span> (<span class="string">"mov $1, %%ebx\n\t"</span></span><br><span class="line">         <span class="string">"mov $14, %%edx\n\t"</span></span><br><span class="line">         <span class="string">"mov $4, %%eax\n\t"</span></span><br><span class="line">         <span class="string">"int $0x80\n\t"</span></span><br><span class="line">         <span class="string">"mov %%eax, %0"</span></span><br><span class="line">         : <span class="string">"=m"</span>(ret)</span><br><span class="line">         : <span class="string">"c"</span>(greeting));</span><br><span class="line">    <span class="keyword">return</span> ret &gt;= <span class="number">0</span> ? <span class="number">0</span> : <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>通过对两段程序的编译执行，我们可以看到它们完成了一样的工作。</p>
<img src="/2016/03/20/系统调用的两种使用方式/sys_call.png" alt="sys_call" title="sys_call">
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>操作系统内核实际上可以视为由一组ISR组成，CPU捕获到中断后陷入到内核态并进入相应的ISR来响应不同的系统事件。系统调用封装了对底层硬件的操作，由内核完成。其使用也是通过中断这一方式。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yangsiran.github.com/2016/03/20/系统调用的两种使用方式/" data-id="cimvc5rud0009x0v9t8kb2vzb" class="article-share-link">Compartir</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Linux/">Linux</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-跟踪Linux内核的启动过程" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/03/13/跟踪Linux内核的启动过程/" class="article-date">
  <time datetime="2016-03-13T02:51:04.000Z" itemprop="datePublished">2016-03-13</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/03/13/跟踪Linux内核的启动过程/">跟踪Linux内核的启动过程</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>杨斯然 原创作品转载请注明出处《Linux内核分析》MOOC课程<a href="http://mooc.study.163.com/course/USTC-1000029000" target="_blank" rel="external">http://mooc.study.163.com/course/USTC-1000029000</a></p>
<p>本文结合Linux内核代码3.18.6中的init/main.c部分代码使用gdb跟踪了Linux操作系统的启动过程(部分)。</p>
<p>使用QEMU加载内核镜像，同时指定根文件系统。启动后效果如下：</p>
<img src="/2016/03/13/跟踪Linux内核的启动过程/booting.png" alt="booting" title="booting">
<p>在QEMU的启动选项中加入<code>-S -s</code>使其在启动时冻结并开放1234端口供gdb调试：</p>
<img src="/2016/03/13/跟踪Linux内核的启动过程/start_qemu.png" alt="start_qemu" title="start_qemu">
<p>进入gdb连接上内核并设置断点在start_kernel处：</p>
<img src="/2016/03/13/跟踪Linux内核的启动过程/setup_gdb.png" alt="setup_gdb" title="setup_gdb">
<p>使用gdb命令c恢复内核运行，内核停止在start_kernel处：<img src="/2016/03/13/跟踪Linux内核的启动过程/start_kernel.png" alt="start_kernel" title="start_kernel"></p>
<p>start_kernel函数对内核的各个模块进行初始化：</p>
<img src="/2016/03/13/跟踪Linux内核的启动过程/src_init_modules1.png" alt="src_init_modules1" title="src_init_modules1">
<p>包括终端、内存、cgroup、console等。</p>
<img src="/2016/03/13/跟踪Linux内核的启动过程/init_modules.png" alt="init_modules" title="init_modules">
<img src="/2016/03/13/跟踪Linux内核的启动过程/src_init_modules2.png" alt="src_init_modules2" title="src_init_modules2">
<p>start_kernel最后调用的函数为rest_init：</p>
<img src="/2016/03/13/跟踪Linux内核的启动过程/rest_init.png" alt="rest_init" title="rest_init">
<img src="/2016/03/13/跟踪Linux内核的启动过程/src_rest_init.png" alt="src_rest_init" title="src_rest_init">
<p>rest_init中启动了根文件系统中的1号用户态进程，启动的kthread内核线程，在最后进入cpu_idle。</p>
<img src="/2016/03/13/跟踪Linux内核的启动过程/init_process.png" alt="init_process" title="init_process">
<p>cpu_idle_loop为0号进程中的一个永久循环，当CPU上没有用户进程被调度时执行：<img src="/2016/03/13/跟踪Linux内核的启动过程/src_idle.png" alt="src_idle" title="src_idle"></p>
<p>启动完毕，进入用户态： <img src="/2016/03/13/跟踪Linux内核的启动过程/done.png" alt="done" title="done"></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yangsiran.github.com/2016/03/13/跟踪Linux内核的启动过程/" data-id="cimvc5rui000cx0v9hnhgvbwb" class="article-share-link">Compartir</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Linux/">Linux</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-一个简单的时间片轮转多道程序内核代码分析" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/03/06/一个简单的时间片轮转多道程序内核代码分析/" class="article-date">
  <time datetime="2016-03-06T02:47:43.000Z" itemprop="datePublished">2016-03-06</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/03/06/一个简单的时间片轮转多道程序内核代码分析/">一个简单的时间片轮转多道程序内核代码分析</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>杨斯然 原创作品转载请注明出处 《Linux内核分析》MOOC课程<a href="http://mooc.study.163.com/course/USTC-1000029000" target="_blank" rel="external">http://mooc.study.163.com/course/USTC-1000029000</a></p>
<p>本文将分析<a href="https://github.com/mengning/mykernel" target="_blank" rel="external">https://github.com/mengning/mykernel</a>中的一个简单调度器。</p>
<p>内核的入口为mymain.c中的<code>void __init my_start_kernel(void)</code>，</p>
<img src="/2016/03/06/一个简单的时间片轮转多道程序内核代码分析/my_main.png" alt="my_main" title="my_main">
<p><code>my_start_kernel</code>初始化了task数组中的4个进程，即四个tPCB结构体。其中pid为进程号（0-3），ip均为my_process的地址，state均为-1（未运行），sp为栈顶位置（tPCB结构中）。所有进程以环形链表的方式组织在一起以便后续轮转调度。</p>
<p>之后的一段汇编代码将0号进程的栈顶赋给esp，并调转到其ip的位置。</p>
<img src="/2016/03/06/一个简单的时间片轮转多道程序内核代码分析/my_process.png" alt="my_process" title="my_process">
<p>所有进程执行的代码均为<code>void my_process(void)</code>，其内容为每执行一段时间检查<code>my_need_sched</code>是否被置1，若是则执行<code>my_schedule()</code>主动让出执行。</p>
<img src="/2016/03/06/一个简单的时间片轮转多道程序内核代码分析/my_timer_handler.png" alt="my_timer_handler" title="my_timer_handler">
<p><code>my_timer_hanlder</code>响应了系统中的定时器中断，当定时器中断一定次数后将<code>my_need_sched</code>置1，以让当前进程主动让出。</p>
<p>调度器的代码在<code>void my_schedule(void)</code>函数中，根据下一个进程（next）的状态（未运行或者运行中）执行不同的调度准备工作。</p>
<img src="/2016/03/06/一个简单的时间片轮转多道程序内核代码分析/my_schedule_1.png" alt="my_schedule_1" title="my_schedule_1">
<p>若下一进程正在运行中：保存当前的ebp到栈上，保存当前的esp到进程结构体中，从目标进程的结构体中回复esp，将下面跳转指令后面的地址作为返回地址保存到进程结构体中，跳转到目标进程。当从目标进程返回时，从栈上恢复ebp。</p>
<img src="/2016/03/06/一个简单的时间片轮转多道程序内核代码分析/my_schedule_2.png" alt="my_schedule_2" title="my_schedule_2">
<p>若下一进程未运行：唯一的区别是将目标进程的栈顶地址也赋给ebp（因为此时目标进程栈为空，且不会恢复ebp），其他部分和上面的情况相同。</p>
<p>这几个函数配合则完成了一个简单的时间片轮转的多道程序内核。以下是内核执行时的进程切换：</p>
<img src="/2016/03/06/一个简单的时间片轮转多道程序内核代码分析/qemu.png" alt="qemu" title="qemu">

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yangsiran.github.com/2016/03/06/一个简单的时间片轮转多道程序内核代码分析/" data-id="cimvc5rty0005x0v9odcoq1sw" class="article-share-link">Compartir</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Linux/">Linux</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-一个简单C程序的反汇编" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/02/28/一个简单C程序的反汇编/" class="article-date">
  <time datetime="2016-02-28T02:36:06.000Z" itemprop="datePublished">2016-02-28</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/02/28/一个简单C程序的反汇编/">一个简单C程序的反汇编</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>杨斯然 原创作品转载请注明出处 《Linux内核分析》MOOC课程<a href="http://mooc.study.163.com/course/USTC-1000029000" target="_blank" rel="external">http://mooc.study.163.com/course/USTC-1000029000</a></p>
<p>现代计算机的运行方式可以被抽象为冯诺依曼体系结构，即存储程序计算机。程序与数据一起被存储在内存（外存）中，CPU按顺序读取程序指令并执行。下面以一个简单的C程序为例子介绍现代计算机的工作方式。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">g</span><span class="params">(<span class="keyword">int</span> x)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x + <span class="number">123</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> x)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> g(x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> f(<span class="number">456</span>) + <span class="number">789</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用以下指令对其进行汇编：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -S main.c -m32</span><br></pre></td></tr></table></figure>
<p>得到汇编代码（删减后）如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">g:</span><br><span class="line">	pushl	%ebp</span><br><span class="line">	movl	%esp, %ebp</span><br><span class="line">	movl	8(%ebp), %eax</span><br><span class="line">	addl	$123, %eax</span><br><span class="line">	popl	%ebp</span><br><span class="line">	ret</span><br><span class="line">f:</span><br><span class="line">	pushl	%ebp</span><br><span class="line">	movl	%esp, %ebp</span><br><span class="line">	subl	$4, %esp</span><br><span class="line">	movl	8(%ebp), %eax</span><br><span class="line">	movl	%eax, (%esp)</span><br><span class="line">	call	g</span><br><span class="line">	leave</span><br><span class="line">	ret</span><br><span class="line">main:</span><br><span class="line">	pushl	%ebp</span><br><span class="line">	movl	%esp, %ebp</span><br><span class="line">	subl	$4, %esp</span><br><span class="line">	movl	$456, (%esp)</span><br><span class="line">	call	f</span><br><span class="line">	addl	$789, %eax</span><br><span class="line">	leave</span><br><span class="line">	ret</span><br></pre></td></tr></table></figure>
<p>整个程序由g、f、main三个函数组成，在具体运行时函数将以main -&gt; f -&gt; g的次序依次被调用。现代计算机使用栈来处理函数间的调用。当发生函数调用时，调用者将参数和返回地址放到栈上，然后跳转到被调用者，被调用者建立新的栈帧。</p>
<p>首先来看main。每次进入函数时，进行栈帧准备工作：将%ebp入栈，并将%esp的值作为新的%ebp（0x2000）。然后准备被调用函数f的参数：将456入栈。调用f，将返回地址（call指令的下一条）入栈。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">main:</span><br><span class="line">	pushl	%ebp</span><br><span class="line">	movl	%esp, %ebp</span><br><span class="line">	subl	$4, %esp</span><br><span class="line">	movl	$456, (%esp)</span><br><span class="line">	call	f</span><br><span class="line">	addl	$789, %eax</span><br><span class="line">	leave</span><br><span class="line">	ret</span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th style="text-align:center">Addr</th>
<th style="text-align:center">Content</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">0x2000</td>
<td style="text-align:center">saved %ebp</td>
</tr>
<tr>
<td style="text-align:center">0x1996</td>
<td style="text-align:center">456</td>
</tr>
<tr>
<td style="text-align:center">0x1992</td>
<td style="text-align:center">address of <code>addl $789, %eax</code></td>
</tr>
</tbody>
</table>
<p>程序跳转到f。同样的准备栈帧，栈帧准备好后参数从<code>8(%ebp)</code>开始。f取出它的第一个参数（456）作为g的参数并入栈。调用g。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">f:</span><br><span class="line">	pushl	%ebp</span><br><span class="line">	movl	%esp, %ebp</span><br><span class="line">	subl	$4, %esp</span><br><span class="line">	movl	8(%ebp), %eax</span><br><span class="line">	movl	%eax, (%esp)</span><br><span class="line">	call	g</span><br><span class="line">	leave</span><br><span class="line">	ret</span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th style="text-align:center">Addr</th>
<th style="text-align:center">Content</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">0x1988</td>
<td style="text-align:center">saved %ebp = 0x2000</td>
</tr>
<tr>
<td style="text-align:center">0x1984</td>
<td style="text-align:center">456</td>
</tr>
<tr>
<td style="text-align:center">0x1980</td>
<td style="text-align:center">address of <code>leave</code> in f</td>
</tr>
</tbody>
</table>
<p>进入函数g。准备栈帧，取出参数（456）到%eax中，对其加123。返回上一级函数，函数返回时对栈帧进行拆除（leave），将%ebp的值赋给%esp，并将栈顶上旧的%ebp恢复到%ebp中。这里由于栈上仅有saved <code>%ebp</code>，只需执行<code>popl %ebp</code>。执行ret返回上一级函数f。返回值在%eax中。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">g:</span><br><span class="line">	pushl	%ebp</span><br><span class="line">	movl	%esp, %ebp</span><br><span class="line">	movl	8(%ebp), %eax</span><br><span class="line">	addl	$123, %eax</span><br><span class="line">	popl	%ebp</span><br><span class="line">	ret</span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th style="text-align:center">Addr</th>
<th style="text-align:center">Content</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">0x1976</td>
<td style="text-align:center">saved %ebp = 0x1988</td>
</tr>
</tbody>
</table>
<p>随后f执行leave拆除栈帧，并返回main。main也执行leave拆除栈帧，并返回。</p>
<p>现代计算机（x86等架构）均为存储程序计算机。程序和数据一起被存储在内存中。CPU通过改变程序计数器（Program Counter）控制程序的顺序执行或跳转。同一ABI下的程序按照一定的标准使用指令、寄存器、栈等硬件资源，如x86-64下的Linux遵循System V ABI。遵循同一套ABI的二进制代码可以互相引用。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yangsiran.github.com/2016/02/28/一个简单C程序的反汇编/" data-id="cimvc5ru50007x0v9wwrkjmzm" class="article-share-link">Compartir</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Linux/">Linux</a></li></ul>

    </footer>
  </div>
  
</article>


  


</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/Linux/">Linux</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Nube de Tags</h3>
    <div class="widget tagcloud">
      <a href="/tags/Linux/" style="font-size: 10px;">Linux</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archivos</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/04/">April 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/03/">March 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/02/">February 2016</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Posts recientes</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2016/04/10/Linux中装载和启动可执行程序/">Linux中装载和启动可执行程序</a>
          </li>
        
          <li>
            <a href="/2016/04/03/Linux内核创建一个新进程的过程/">Linux内核创建一个新进程的过程</a>
          </li>
        
          <li>
            <a href="/2016/03/27/system-call中断的处理过程/">system_call中断的处理过程</a>
          </li>
        
          <li>
            <a href="/2016/03/20/系统调用的两种使用方式/">系统调用的两种使用方式</a>
          </li>
        
          <li>
            <a href="/2016/03/13/跟踪Linux内核的启动过程/">跟踪Linux内核的启动过程</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2016 Siran Yang<br>
      Construido por <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>




  </div>
</body>
</html>